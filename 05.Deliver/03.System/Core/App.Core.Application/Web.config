<?xml version="1.0" encoding="utf-8"?>

<!--
  For more information on how to configure your ASP.NET application, please visit
  https://go.microsoft.com/fwlink/?LinkId=301880
  -->
<configuration>
  <configSections>

    <section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
    <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->
  </configSections>

  <!-- AppCoreDatabaseInitializer -->

  <!-- 
       Externalize Secrets so they are not checked in:
       Use the file attribute to eference an external file .gitignored file, to keep credentials, etc.
       It's true that it's always best to not have any credentials at all in the config, injecting them 
       in via the build pipeline. But dev's don't have a 'desktop-pipeline', so this is an old-school hack
       that works up to a point (a notable issue is when users don't use integrated-security in their 
       connection strings).
       IMPORTANT: External file must be marked as 'Copy To Output: If Newer' or it won't find it.
 
   <appSettings file="web.config.appsettings.secret">
 
 -->
  <appSettings>
    <add key="App-Code-DemoMode" value="false" />

    <!-- SECTION: Default ASP.MVC stuff: -->
    <add key="webpages:Version" value="3.0.0.0" />
    <add key="webpages:Enabled" value="false" />
    <add key="ClientValidationEnabled" value="true" />
    <add key="UnobtrusiveJavaScriptEnabled" value="true" />

    <!-- Tip: 'StorageConnectionString' is a BuiltIn key that shortcircuits 
         storage to go to local storage emulator rather than on Azure -->
    <add key="StorageConnectionString" value="UseDevelopmentStorage=false;" />

    <!-- REQUIRED / APPSETTINGS :
    // Azure Common:
    // The following setting should not be set here by developers...
    // They should use .gitignored file.
    // Build Servers should overwrite it.
    "App-Core-Integration-Azure-Common-ResourceName"
     -->


    <!-- REQUIRED/ KEYVAULT SETTINGS"
    // The following are Settings that are absolutely required in the KeyVault
    // pointed to by the "App-Core-Integration-KeyVault-ResourceName", unless its
    // falling back to the "App-Core-Integration-Common-ResourceName":
    Note that the InstrumentationKey should be set per environment (ie, ARM Built)
    "App-Core-Integration-Azure-ApplicationInsights-InstrumentationKey"
    "App-Core-Integration-MalwareDetection-Scanii-Key"
    "App-Core-Integration-MalwareDetection-Scanii-Secret"
      "App-Core-Integration-Azure-StorageAccount-Diagnostics-Key"
        "App-Core-Integration-Azure-StorageAccount-Media1-Key"
        "App-Core-Integration-Azure-StorageAccount-Media2-Key"
        "App-Core-Integration-Azure-DocumentDb-AuthorizationKey"
    -->



    <!-- SECTION: SECURITY/CONFIDENTIALITY/TLS -->
    <!-- For Security Objectives: define that all outgoing requests are over Tls12 -->
    <add key="App-Core-TLS-SecurityProtocol" value="Tls12" />

    <!-- SECTION: MEDIA/UPLOAD HANDLING-->
    <add key="App-Core-Media-HashType" value="SHA-256" />

    <!-- SECTION: CODEFIRST DATABASE AS CODE -->



    <!-- OPTIONAL APPSETTINGS
    "App-Code-DemoMode" value="true|false"
    //Seeding from Powershell can be difficult to debug. This Attaches a Debugger:
    "App-Core-Integration-Sql-CodeFirst-AttachDebuggerToPSSeeding" value="true|false" />
    // Seeding can include demo records to get going quicker:
    "App-Core-Integration-Sql-CodeFirst-SeedIncludeDemoEntries" value="true|false" />
    // Systems that have UIs need info about the app, creator, distributor:
    "App-Core-Application-Name"
    "App-Core-Application-Description"
    "App-Core-Application-Creator-Name"
    "App-Core-Application-Creator-Description"
    "App-Core-Application-Creator-SiteUrl"
    "App-Core-Application-Creator-ContactUrl"
    "App-Core-Application-Distributor-Name"
    "App-Core-Application-Distributor-Description"
    "App-Core-Application-Distributor-SiteUrl"
    "App-Core-Application-Distributor-ContactUrl"
    // If Azure Resource Names are not provided, they fall back to the Common Resource Name
    // hence why it's required...even if these are not:
    "App-Core-Integration-Azure-KeyVaultStores-ResourceName"
    
    "App-Core-Integration-Azure-StorageAccount-Diagnostics-ResourceName"
    "App-Core-Integration-Azure-StorageAccount-Media1-ResourceName"
    "App-Core-Integration-Azure-StorageAccount-Media2-ResourceName"
    "App-Core-Integration-Azure-DocumentDb-ResourceName"

    "App-Core-Integration-Azure-StorageAccount-Diagnostics-ResourceNameSuffix"
    "App-Core-Integration-Azure-StorageAccount-Media1-ResourceNameSuffix"
    "App-Core-Integration-Azure-StorageAccount-Media2-ResourceNameSuffix"
    "App-Core-Integration-Azure-DocumentDb-ResourceNameSuffix"
    

    // Diagnostics should be enabled, but maybe you want to wait till you have other things sorted out:
    <add key="App-Core-Integration-Azure-ApplicationInsights-Enabled" value="false" />
    // Most of the Scanii settings (secrets) are configured form the KeyVault, except for this optional path:
    <add key="App-Core-Integration-MalwareDetection-Scanii-BaseUri" value="https://api-ap1.scanii.com/v2.1/" />
    -->

    <!-- KEYVAULT SETTINGS / OPTIONAL
    TODO:
    -->


    <add key="App-Core-Integration-Azure-Common-ResourceName" value="nzmoebase0000bt" />
    <add key="App-Core-Integration-Sql-CodeFirst-AttachDebuggerToPSSeeding" value="true" />
    <add key="App-Core-Integration-Sql-CodeFirst-SeedIncludeDemoEntries" value="true" />




    <!-- SECTION: Azure / AppInsights -->

    <!-- SECTION: IDA: OIDC Integration-->
    <add key="App-Core-Integration-ida-AuthorityUriType" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-AuthorityTenantName" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-AuthorityUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-AuthorityCookieConfigurationPolicyUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-AuthorityTokenConfigurationPolicyUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-DefaultPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-SignUpPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-SignInPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-SignUpSignInPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-UserProfilePolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-EditProfilePolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-ResetPasswordPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />

    <!-- <add key="App-Core-Integration-ida-AadInstance" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" /> -->
    <add key="App-Core-Integration-ida-AuthorityUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-ClientId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-ClientSecret" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-RedirectUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App-Core-Integration-ida-ClientPostLogoutUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />


    <!-- MODULE 2 SPECIFIC -->
    <add key="App-Module2-SchoolImportSourcePath" value="Z:\U\SKY\D\NOSYNC\Repositories\FooDemoServer\FooDemoServer" />


  </appSettings>

  <connectionStrings>
    <add name="AppCoreDbContext" providerName="System.Data.SqlClient" connectionString="Data Source=(localdb)\mssqllocaldb;Database=AppDbContext;Integrated Security=True" />
  </connectionStrings>


  <entityFramework>
    <defaultConnectionFactory type="System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework">
      <parameters>
        <parameter value="mssqllocaldb" />
      </parameters>
    </defaultConnectionFactory>
    <providers>
      <provider invariantName="System.Data.SqlClient" type="System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer" />
    </providers>
    <!-- You can set the DbContext Initializer via config, or via AppCoreDatabaseInitializerConfigure, AppModule1DatabaseInitializerConfigure, etc. -->
    <contexts>
      <!-- Tip: Use Type and Assembly name. Or FQ name as long as it is exactly right (or it won't find it) -->
      <!-- Tip: You won't be able to Resharper F12 until App.Core.Application has a direct reference to App.xxx.Infrastructure -->
      <context type="App.Core.Infrastructure.Db.Context.AppCoreDbContext, App.Core.Infrastructure">
        <databaseInitializer type="App.Core.Infrastructure.Db.Context.AppCoreDatabaseInitializer, App.Core.Infrastructure" />
      </context>
      <context type="App.Module1.Infrastructure.Db.Context.AppModule1DbContext, App.Module1.Infrastructure">
        <databaseInitializer type="App.Module1.Infrastructure.Db.Context.AppModule1DatabaseInitializer, App.Module1.Infrastructure" />
      </context>
      <context type="App.Module2.Infrastructure.Db.Context.AppModule2DbContext, App.Module2.Infrastructure">
        <databaseInitializer type="App.Module2.Infrastructure.Db.Context.AppModule2DatabaseInitializer, App.Module2.Infrastructure" />
      </context>
      <context type="App.Module3.Infrastructure.Db.Context.AppModule3DbContext, App.Module3.Infrastructure">
        <databaseInitializer type="App.Module3.Infrastructure.Db.Context.AppModule3DatabaseInitializer, App.Module3.Infrastructure" />
      </context>
    </contexts>
  </entityFramework>

  <!-- SETUP: Lock off access to temp Upload directory -->
  <location path="Uploads">
    <system.web>
      <authorization>
        <deny users="*" />
      </authorization>
    </system.web>
  </location>


  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
        <bindingRedirect oldVersion="0.0.0.0-10.0.0.0" newVersion="10.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.Optimization" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="1.0.0.0-1.1.0.0" newVersion="1.1.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="WebGrease" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="0.0.0.0-1.6.5135.21930" newVersion="1.6.5135.21930" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.Helpers" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="1.0.0.0-5.2.3.0" newVersion="5.2.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.WebPages" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.Http" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.2.3.0" newVersion="5.2.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Net.Http.Formatting" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.2.3.0" newVersion="5.2.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Owin" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.1.0.0" newVersion="3.1.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.IdentityModel.Tokens.Jwt" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.40306.1554" newVersion="4.0.40306.1554" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Net.Http" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.1" newVersion="4.1.1.1" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.OData.Core" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-7.3.1.10814" newVersion="7.3.1.10814" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.OData.Edm" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-7.3.1.10814" newVersion="7.3.1.10814" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Extensions.DependencyInjection.Abstractions" publicKeyToken="adb9793829ddae60" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.1.1.0" newVersion="1.1.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Extensions.DependencyInjection" publicKeyToken="adb9793829ddae60" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.1.1.0" newVersion="1.1.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Spatial" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-7.3.1.10814" newVersion="7.3.1.10814" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Xml.ReaderWriter" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.0.0" newVersion="4.1.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Antlr3.Runtime" publicKeyToken="eb42632606e9261f" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.5.0.2" newVersion="3.5.0.2" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Protocols" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-2.1.4.0" newVersion="2.1.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Tokens" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.1.4.0" newVersion="5.1.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Logging" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.1.4.0" newVersion="1.1.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.ApplicationInsights" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-2.4.0.0" newVersion="2.4.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Protocol.Extensions" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.0.40306.1554" newVersion="1.0.40306.1554" />
      </dependentAssembly>

      <!--
          IF you put your plugin in a folder that isn't bin, add it to the probing path
      -->
      <!--<probing privatePath="bin;bin\plugins" />-->
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Clients.ActiveDirectory" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.17.2.31801" newVersion="3.17.2.31801" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Clients.ActiveDirectory.Platform" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.17.2.31801" newVersion="3.17.2.31801" />
      </dependentAssembly>
    </assemblyBinding>

  </runtime>


  <system.codedom>
    <compilers>
      <compiler language="c#;cs;csharp" extension=".cs" type="Microsoft.CodeDom.Providers.DotNetCompilerPlatform.CSharpCodeProvider, Microsoft.CodeDom.Providers.DotNetCompilerPlatform, Version=1.0.5.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" warningLevel="4" compilerOptions="/langversion:default /nowarn:1659;1699;1701" />
      <compiler language="vb;vbs;visualbasic;vbscript" extension=".vb" type="Microsoft.CodeDom.Providers.DotNetCompilerPlatform.VBCodeProvider, Microsoft.CodeDom.Providers.DotNetCompilerPlatform, Version=1.0.5.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" warningLevel="4" compilerOptions="/langversion:default /nowarn:41008 /define:_MYTYPE=\&quot;Web\&quot; /optionInfer+" />
    </compilers>
  </system.codedom>


  <system.web>


    <!-- 
    SETUP STEP: for optimizeCompilations, see https://blogs.msdn.microsoft.com/davidebb/2009/04/15/a-new-flag-to-optimize-asp-net-compilation-behavior/
    -->
    <compilation optimizeCompilations="true" debug="true" targetFramework="4.6.1">
      <assemblies>
        <!--<add assembly="App.Module1.Application" />
        <add assembly="App.Module2.Application" />-->
      </assemblies>
    </compilation>

    <!-- SETUP STEP: Allow for remote debuging when deployed to Azure by setting to Off (On/Off/RemoteOnly)-->

    <!-- Do not use system.web/customErrors(IIS6). Use system.webServer/httpErrors (IIS7+). -->
    <!--<customErrors mode="On" defaultRedirect="/HttpErrors/HTTP500.html" redirectMode="ResponseRewrite">
      <error statusCode="400" redirect="/HttpErrors/HTTP400.html" />
      <error statusCode="401" redirect="/HttpErrors/HTTP401.html" />
      <error statusCode="402" redirect="/HttpErrors/HTTP402.html" />
      <error statusCode="403" redirect="/HttpErrors/HTTP403.html" />
      -->
    <!--<error statusCode="404" redirect="/HttpErrors/HTTP404.html" />-->
    <!--
      <error statusCode="500" redirect="/HttpErrors/HTTP500.html" />
    </customErrors>-->


    <customErrors mode="Off" />

    <!-- SETUP STEP -->
    <!-- For Security Objectives: mitigate XSS, by decorating cookies with HttpOnlyCookies, 
         making them inaccessible to client-side scripts.  
         Ensure cookies are not sent over unencrypted wires by setting require SSL 
         -->
    <httpCookies httpOnlyCookies="true" requireSSL="true" />


    <httpModules>
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" />
    </httpModules>
    <!--
    As per:
    https://msdn.microsoft.com/en-us/library/e1f13641(v=vs.100).aspx
    https://blogs.msdn.microsoft.com/webdev/2012/11/19/all-about-httpruntime-targetframework/
    For Security objectives: We can replace the default encoder with the more capable XSS nuget package's Encoder.
    Note that in ASP.NET Core this is no longer a requirement as they did a better job.
    
    For Security objectives: Remove the overly verbose X-AspNet-Version header by setting enableVersionHeader=false 
              Note that Visual Studio uses this to determine the ASP.NET version.
    -->
    <httpRuntime enableVersionHeader="false" encoderType="System.Web.Security.AntiXss.AntiXssEncoder" requestValidationMode="4.0" targetFramework="4.6.1" />



  </system.web>


  <system.webServer>

    <handlers>
      <remove name="ExtensionlessUrlHandler-Integrated-4.0" />
      <!-- Ensure OPTIONS handler is removed, or CORS won't work as expected: http://benfoster.io/blog/aspnet-webapi-cors-->
      <remove name="OPTIONSVerbHandler" />
      <remove name="TRACEVerbHandler" />
      <add name="ExtensionlessUrlHandler-Integrated-4.0" path="*." verb="*" type="System.Web.Handlers.TransferRequestHandler" preCondition="integratedMode,runtimeVersionv4.0" />
    </handlers>

    <!-- 
     Notes regarding using httpErrors.
     a) The objective we are after is to display a prettier error page. 
        But the response http error code (eg: HTTP404.html) must 
        not be '200' (that makes no sense - even if it is the default). 
        It must be the actual error code itself.
        You can check that by using F12 in chrome, and put in a nonsense path.
     b) It's trickier than it looks. To do it:
     c) remove customErrors tag completely (only was needed for IIS6. HttpErrors is the new route)
     d) errorMode: use Custom generally, or DetailedLocalOnly, unless *debugging in Azure* in which case use `Detailed` 
     e) existingResponse: use "Replace", or you'll see the IIS error.
     f) existingResponse: use File to return an HTTP file.
     f) pay attention to path used:
        if httpErrors@defaultResponseMode or error@responseMode is set to `File`, 
        then paths have to use forward slashes as they are filepaths - not urls.
     errorMode="DetailedLocalOnly|Detailed|Custom"
     existingResponse="Auto|Replace|PassThrough"
     defaultResponseMode="File|ExecuteURL|Redirect"
     
                existingResponse="Replace"
    <httpErrors errorMode="DetailedLocalOnly" defaultResponseMode="File">
     -->
    <!--TAKEN OUT TILL WE GET UP AND RUNNING ON AZURE: <httpErrors errorMode="Detailed" defaultResponseMode="File">
      <clear />
      <error statusCode="400" path="HttpErrors\HTTP400.html" />
      <error statusCode="401" path="HttpErrors\HTTP401.html" />
      <error statusCode="403" path="HttpErrors\HTTP403.html" />
      <error statusCode="404" path="httperrors\http404.html" />
      <error statusCode="500" path="HttpErrors\HTTP500.html" />
      <error statusCode="501" path="HttpErrors\HTTP501.html" />
      <error statusCode="502" path="HttpErrors\HTTP502.html" />
      <error statusCode="503" path="HttpErrors\HTTP503.html" />
      <error statusCode="520" path="HttpErrors\HTTP520.html" />
      <error statusCode="521" path="HttpErrors\HTTP521.html" />
      <error statusCode="533" path="HttpErrors\HTTP533.html" />
    </httpErrors>-->

    <!-- SETUP STEP: Ensure Traffic is only over SSL-->
    <httpProtocol>
      <customHeaders>
        <remove name="X-Powered-By" />
        <!-- This Will conflict with Redirection. In other words, after clearing caching
             the site will accept a single unsecure request (eg: http://localhost:60011) and
             redirect it correctly to (eg: https://localhost:43311)...but with this header on it...
             which means the browser will no longer even bother sending a request to http://localhost:60011
             and client side updates it to making a request for https://localhost:60011 to which 
             there is no handler. Hence no redirection occurs. A poor end-user experience.-->
        <!--<add name="Strict-Transport-Security" value="max-age=16070400; includeSubDomains" />-->

        <!-- 
            For example: 
            limit all (using `default-src`) to being loaded over HTTPS
            limit scripts (using `script-src`) to self and Google’s CDN (https://ajax.googleapis.com)
            limit styles (using `style-src`) to self and Google’s CDN (https://ajax.googleapis.com). 
            limit images (using `img-src`) to our domain only. 
        -->
        
      </customHeaders>
    </httpProtocol>
    <!-- SETUP STEP: Ensure runAllManagedModulesForAllRequests (RAMMFAR) is true in order to ensure that 
    static resource requests can be throttled in case of a DNS attack
    -->
    <modules runAllManagedModulesForAllRequests="false">
      <!-- TelemetryCorrelationHttpModule is added when you sign up and configure App Insights-->
      <remove name="TelemetryCorrelationHttpModule" />
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" preCondition="integratedMode,managedHandler" />
      <!-- ApplicationInsightsWebTracking was available upon new build -->
      <remove name="ApplicationInsightsWebTracking" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" preCondition="managedHandler" />
    </modules>
    <validation validateIntegratedModeConfiguration="false" />
  </system.webServer>


  <system.diagnostics>
    <trace autoflush="true" indentsize="0">
      <listeners>
        <!--
        TODO: Removed me
        <add name="myAppInsightsListener" type="Microsoft.ApplicationInsights.TraceListener.ApplicationInsightsTraceListener, Microsoft.ApplicationInsights.TraceListener" />
        -->
      </listeners>
    </trace>
  </system.diagnostics>


</configuration>