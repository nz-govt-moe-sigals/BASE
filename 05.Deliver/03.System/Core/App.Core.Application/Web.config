<?xml version="1.0" encoding="utf-8"?>

<!--
  For more information on how to configure your ASP.NET application, please visit
  https://go.microsoft.com/fwlink/?LinkId=301880
  -->
<configuration>
  <configSections>

    <section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
    <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --></configSections>

  <!-- AppCoreDatabaseInitializer -->

  <!-- 
       Externalize Secrets so they are not checked in:
       Use the file attribute to eference an external file .gitignored file, to keep credentials, etc.
       It's true that it's always best to not have any credentials at all in the config, injecting them 
       in via the build pipeline. But dev's don't have a 'desktop-pipeline', so this is an old-school hack
       that works up to a point (a notable issue is when users don't use integrated-security in their 
       connection strings).
       IMPORTANT: External file must be marked as 'Copy To Output: If Newer' or it won't find it.
 
   <appSettings file="web.config.appsettings.secret">
 
 -->
  <appSettings>
    <!-- SECTION: Default ASP.MVC stuff: -->
    <add key="webpages:Version" value="3.0.0.0" />
    <add key="webpages:Enabled" value="false" />
    <add key="ClientValidationEnabled" value="true" />
    <add key="UnobtrusiveJavaScriptEnabled" value="true" />
    <!-- SECTION: Analytics Integration -->
    <!-- Tip: 'StorageConnectionString' is a BuiltIn key that shortcircuits 
         storage to go to local storage emulator rather than on Azure -->
    <add key="StorageConnectionString" value="UseDevelopmentStorage=false;" />


    <!-- SECTION: Application Description -->
    <add key="App:Core:Application:Name" value="HAPI"/>
    <add key="App:Core:Application:Description" value="HAPI"/>
    <add key="App:Core:Application:Creator:Name" value="TODO"/>
    <add key="App:Core:Application:Creator:Description" value="TODO"/>
    <add key="App:Core:Application:Creator:SiteUrl" value="TODO"/>
    <add key="App:Core:Application:Creator:ContactUrl" value="TODO"/>
    <add key="App:Core:Application:Distributor:Name" value="TODO"/>
    <add key="App:Core:Application:Distributor:Description" value="TODO"/>
    <add key="App:Core:Application:Distributor:SiteUrl" value="TODO"/>
    <add key="App:Core:Application:Distributor:ContactUrl" value="TODO"/>

    <add key="App:Code:DemoMode" value="false"/>

    <!-- SECTION: KeyVault -->
    <!-- The Key Vault is used to persist Secrets rather than poluting the App's Config files 
    -->
              
    <add key="App:Core:Integration:Azure:KeyVaultStores:DisableConfigurationCheck" value="false"/>
    <add key="App:Core:Integration:Azure:KeyVaultStores:System:Url" value ="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE"/>
    <add key="App:Core:Integration:Azure:KeyVaultStores:Organisation:Url" value ="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE"/>

    <add key="App:Core:Integration:Azure:ApplicationInsights:Disable" value="true" />
    <!-- Note that the Key should be set per target environment DT, BT, ST, UAT, PROD -->
    <add key="App:Core:Integration:Azure:ApplicationInsights:InstrumentationKey" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />

   
    <!-- SECTION: Malware Detection Service Integration -->
    <add key="App:Core:Integration:MalwareDetection:Scanii:PingAtStartup" value="True"/>
    <add key="App:Core:Integration:MalwareDetection:Scanii:Key" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:Integration:MalwareDetection:Scanii:Secret" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <!-- Geo-routed endpoint is https://api.scanii.com/v2.1/, but direct is https://api-ap1.scanii.com/v2.1/ -->
    <add key="App:Core:Integration:MalwareDetection:Scanii:BaseUri" value="https://api-ap1.scanii.com/v2.1/" />
    <!-- SECTION: IDA: OIDC Integration-->
    <add key="App:Core:ida:AuthorityUriType" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:AuthorityTenantName" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:AuthorityUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:AuthorityCookieConfigurationPolicyUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:AuthorityTokenConfigurationPolicyUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:DefaultPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:SignUpPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:SignInPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:SignUpSignInPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:UserProfilePolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:EditProfilePolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:ResetPasswordPolicyId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <!-- <add key="App:Core:ida:AadInstance" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" /> -->
    <add key="App:Core:ida:AuthorityUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:ClientId" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:ClientSecret" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:RedirectUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />
    <add key="App:Core:ida:ClientPostLogoutUri" value="OVERRIDED USING EXT. .GITIGNORED APPSETTINGS FILE" />

    
    <!-- SECTION: SECURITY/CONFIDENTIALITY/TLS -->
    <!-- For Security Objectives: define that all outgoing requests are over Tls12 -->
    <add key="App:Core:TLS:SecurityProtocol" value="Tls12" />

    <!-- SECTION: CODEFIRST DATABASE AS CODE -->
    <!-- Seeding from Powershell can be difficult to debug. THis Attaches a Debugger-->
    <add key="App:Core:CodeFirst:AttachDebuggerToPSSeeding" value="true" />
    <add key="App:Core:CodeFirst:SeedIncludeDemoEntries" value="true" />


    <!-- SECTION: MEDIA/UPLOAD HANDLING-->
    <add key="App:Core:Media:HashType" value="SHA-256" />


    <!-- MODULE 2 SPECIFIC -->
    <add key="App:Module2:SchoolImportSourcePath" value="Z:\U\SKY\D\NOSYNC\Repositories\FooDemoServer\FooDemoServer" />

  
  </appSettings>

  <connectionStrings>
    <add name="AppCoreDbContext" providerName="System.Data.SqlClient" connectionString="Data Source=(localdb)\mssqllocaldb;Database=AppDbContext;Integrated Security=True" />
  </connectionStrings>


  <entityFramework>
    <defaultConnectionFactory type="System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework">
      <parameters>
        <parameter value="mssqllocaldb" />
      </parameters>
    </defaultConnectionFactory>
    <providers>
      <provider invariantName="System.Data.SqlClient" type="System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer" />
    </providers>
    <!-- You can set the DbContext Initializer via config, or via AppCoreDatabaseInitializerConfigure, AppModule1DatabaseInitializerConfigure, etc. -->
    <contexts>
      <!-- Tip: Use Type and Assembly name. Or FQ name as long as it is exactly right (or it won't find it) -->
      <!-- Tip: You won't be able to Resharper F12 until App.Core.Application has a direct reference to App.xxx.Infrastructure -->
      <context type="App.Core.Infrastructure.Db.Context.AppCoreDbContext, App.Core.Infrastructure">
        <databaseInitializer type="App.Core.Infrastructure.Db.Context.AppCoreDatabaseInitializer, App.Core.Infrastructure" />
      </context>
      <context type="App.Module1.Infrastructure.Db.Context.AppModule1DbContext, App.Module1.Infrastructure">
        <databaseInitializer type="App.Module1.Infrastructure.Db.Context.AppModule1DatabaseInitializer, App.Module1.Infrastructure" />
      </context>
      <context type="App.Module2.Infrastructure.Db.Context.AppModule2DbContext, App.Module2.Infrastructure">
        <databaseInitializer type="App.Module2.Infrastructure.Db.Context.AppModule2DatabaseInitializer, App.Module2.Infrastructure" />
      </context>
    </contexts>
  </entityFramework>

  <!-- SETUP: Lock off access to temp Upload directory -->
  <location path="Uploads">
    <system.web>
      <authorization>
        <deny users="*" />
      </authorization>
    </system.web>
  </location>
  

  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
        <bindingRedirect oldVersion="0.0.0.0-10.0.0.0" newVersion="10.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.Optimization" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="1.0.0.0-1.1.0.0" newVersion="1.1.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="WebGrease" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="0.0.0.0-1.6.5135.21930" newVersion="1.6.5135.21930" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.Helpers" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="1.0.0.0-5.2.3.0" newVersion="5.2.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.WebPages" publicKeyToken="31bf3856ad364e35" />
        <bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Web.Http" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.2.3.0" newVersion="5.2.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Net.Http.Formatting" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.2.3.0" newVersion="5.2.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Owin" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.1.0.0" newVersion="3.1.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.IdentityModel.Tokens.Jwt" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.40306.1554" newVersion="4.0.40306.1554" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Net.Http" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.1" newVersion="4.1.1.1" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.OData.Core" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-7.3.1.10814" newVersion="7.3.1.10814" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.OData.Edm" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-7.3.1.10814" newVersion="7.3.1.10814" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Extensions.DependencyInjection.Abstractions" publicKeyToken="adb9793829ddae60" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.1.1.0" newVersion="1.1.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Extensions.DependencyInjection" publicKeyToken="adb9793829ddae60" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.1.1.0" newVersion="1.1.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Spatial" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-7.3.1.10814" newVersion="7.3.1.10814" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Xml.ReaderWriter" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.0.0" newVersion="4.1.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Antlr3.Runtime" publicKeyToken="eb42632606e9261f" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.5.0.2" newVersion="3.5.0.2" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Protocols" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-2.1.4.0" newVersion="2.1.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Tokens" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.1.4.0" newVersion="5.1.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Logging" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.1.4.0" newVersion="1.1.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.ApplicationInsights" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-2.4.0.0" newVersion="2.4.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.IdentityModel.Protocol.Extensions" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.0.40306.1554" newVersion="1.0.40306.1554" />
      </dependentAssembly>

      <!--
          IF you put your plugin in a folder that isn't bin, add it to the probing path
      -->
      <!--<probing privatePath="bin;bin\plugins" />-->
    </assemblyBinding>

  </runtime>


  <system.codedom>
    <compilers>
      <compiler language="c#;cs;csharp" extension=".cs" type="Microsoft.CodeDom.Providers.DotNetCompilerPlatform.CSharpCodeProvider, Microsoft.CodeDom.Providers.DotNetCompilerPlatform, Version=1.0.5.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" warningLevel="4" compilerOptions="/langversion:default /nowarn:1659;1699;1701" />
      <compiler language="vb;vbs;visualbasic;vbscript" extension=".vb" type="Microsoft.CodeDom.Providers.DotNetCompilerPlatform.VBCodeProvider, Microsoft.CodeDom.Providers.DotNetCompilerPlatform, Version=1.0.5.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" warningLevel="4" compilerOptions="/langversion:default /nowarn:41008 /define:_MYTYPE=\&quot;Web\&quot; /optionInfer+" />
    </compilers>
  </system.codedom>


  <system.web>
    
    
    <!-- 
    SETUP STEP: for optimizeCompilations, see https://blogs.msdn.microsoft.com/davidebb/2009/04/15/a-new-flag-to-optimize-asp-net-compilation-behavior/
    -->
    <compilation optimizeCompilations="true" debug="true" targetFramework="4.6.1">
      <assemblies>
        <!--<add assembly="App.Module1.Application" />
        <add assembly="App.Module2.Application" />-->
      </assemblies>
    </compilation>

    <!-- SETUP STEP: Allow for remote debuging when deployed to Azure by setting to Off (On/Off/RemoteOnly)-->

    <!-- Do not use system.web/customErrors(IIS6). Use system.webServer/httpErrors (IIS7+). -->
    <!--<customErrors mode="On" defaultRedirect="/HttpErrors/HTTP500.html" redirectMode="ResponseRewrite">
      <error statusCode="400" redirect="/HttpErrors/HTTP400.html" />
      <error statusCode="401" redirect="/HttpErrors/HTTP401.html" />
      <error statusCode="402" redirect="/HttpErrors/HTTP402.html" />
      <error statusCode="403" redirect="/HttpErrors/HTTP403.html" />
      --><!--<error statusCode="404" redirect="/HttpErrors/HTTP404.html" />--><!--
      <error statusCode="500" redirect="/HttpErrors/HTTP500.html" />
    </customErrors>-->

    <!-- SETUP STEP -->
    <!-- For Security Objectives: mitigate XSS, by decorating cookies with HttpOnlyCookies, 
         making them inaccessible to client-side scripts.  
         Ensure cookies are not sent over unencrypted wires by setting require SSL 
         -->
    <httpCookies httpOnlyCookies="true" requireSSL="true" />


    <httpModules>
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" />
    </httpModules>
    <!--
    As per:
    https://msdn.microsoft.com/en-us/library/e1f13641(v=vs.100).aspx
    https://blogs.msdn.microsoft.com/webdev/2012/11/19/all-about-httpruntime-targetframework/
    For Security objectives: We can replace the default encoder with the more capable XSS nuget package's Encoder.
    Note that in ASP.NET Core this is no longer a requirement as they did a better job.
    
    For Security objectives: Remove the overly verbose X-AspNet-Version header by setting enableVersionHeader=false 
              Note that Visual Studio uses this to determine the ASP.NET version.
    -->
    <httpRuntime enableVersionHeader="false" encoderType="System.Web.Security.AntiXss.AntiXssEncoder" requestValidationMode="4.0" targetFramework="4.6.1" />


    
  </system.web>


  <system.webServer>

    <handlers>
      <remove name="ExtensionlessUrlHandler-Integrated-4.0" />
      <!-- Ensure OPTIONS handler is removed, or CORS won't work as expected: http://benfoster.io/blog/aspnet-webapi-cors-->
      <remove name="OPTIONSVerbHandler" />
      <remove name="TRACEVerbHandler" />
      <add name="ExtensionlessUrlHandler-Integrated-4.0" path="*." verb="*" type="System.Web.Handlers.TransferRequestHandler" preCondition="integratedMode,runtimeVersionv4.0" />
    </handlers>

    <!-- 
     Notes regarding using httpErrors.
     a) The objective we are after is to display a prettier error page. 
        But the response http error code (eg: HTTP404.html) must 
        not be '200' (that makes no sense - even if it is the default). 
        It must be the actual error code itself.
        You can check that by using F12 in chrome, and put in a nonsense path.
     b) It's trickier than it looks. To do it:
     c) remove customErrors tag completely (only was needed for IIS6. HttpErrors is the new route)
     d) errorMode: use Custom generally, or DetailedLocalOnly, unless *debugging in Azure* in which case use `Detailed` 
     e) existingResponse: use "Replace", or you'll see the IIS error.
     f) existingResponse: use File to return an HTTP file.
     f) pay attention to path used:
        if httpErrors@defaultResponseMode or error@responseMode is set to `File`, 
        then paths have to use forward slashes as they are filepaths - not urls.
     errorMode="DetailedLocalOnly|Detailed|Custom"
     existingResponse="Auto|Replace|PassThrough"
     defaultResponseMode="File|ExecuteURL|Redirect"
     
                existingResponse="Replace"
     -->
    <httpErrors errorMode="DetailedLocalOnly" defaultResponseMode="File">
      <clear />
      <error statusCode="400" path="HttpErrors\HTTP400.html" />
      <error statusCode="401" path="HttpErrors\HTTP401.html" />
      <error statusCode="403" path="HttpErrors\HTTP403.html" />
      <error statusCode="404" path="httperrors\http404.html" />
      <error statusCode="500" path="HttpErrors\HTTP500.html" />
      <error statusCode="501" path="HttpErrors\HTTP501.html" />
      <error statusCode="502" path="HttpErrors\HTTP502.html" />
      <error statusCode="503" path="HttpErrors\HTTP503.html" />
      <error statusCode="520" path="HttpErrors\HTTP520.html" />
      <error statusCode="521" path="HttpErrors\HTTP521.html" />
      <error statusCode="533" path="HttpErrors\HTTP533.html" />
    </httpErrors>

    <!-- SETUP STEP: Ensure Traffic is only over SSL-->
    <httpProtocol>
      <customHeaders>
        <remove name="X-Powered-By" />
        <!-- This Will conflict with Redirection. In other words, after clearing caching
             the site will accept a single unsecure request (eg: http://localhost:60011) and
             redirect it correctly to (eg: https://localhost:43311)...but with this header on it...
             which means the browser will no longer even bother sending a request to http://localhost:60011
             and client side updates it to making a request for https://localhost:60011 to which 
             there is no handler. Hence no redirection occurs. A poor end-user experience.-->
        <!--<add name="Strict-Transport-Security" value="max-age=16070400; includeSubDomains" />-->

        <!-- 
            For example: 
            limit all (using `default-src`) to being loaded over HTTPS
            limit scripts (using `script-src`) to self and Google’s CDN (https://ajax.googleapis.com)
            limit styles (using `style-src`) to self and Google’s CDN (https://ajax.googleapis.com). 
            limit images (using `img-src`) to our domain only. 
        -->
        <add name="Content-Security-Policy" value="default-src https:; connect-src 'self' https://ajax.googleapis.com; script-src 'self' https://ajax.googleapis.com  'sha256-yz8EGXlVkTdxTCpTtHtqng7oE3bwX3orfonAmITU84M='; style-src 'self' https://ajax.googleapis.com 'sha256-MZKTI0Eg1N13tshpFaVW65co/LeICXq4hyVx6GWVlK0=' 'sha256-LpfmXS+4ZtL2uPRZgkoR29Ghbxcfime/CsD/4w5VujE=' 'sha256-YJO/M9OgDKEBRKGqp4Zd07dzlagbB+qmKgThG52u/Mk='; img-src 'self'" />
      </customHeaders>
    </httpProtocol>
    <!-- SETUP STEP: Ensure runAllManagedModulesForAllRequests (RAMMFAR) is true in order to ensure that 
    static resource requests are can be throttled in case of a DNS attack
    -->
    <modules runAllManagedModulesForAllRequests="true">
      <!-- TelemetryCorrelationHttpModule is added when you sign up and configure App Insights-->
      <remove name="TelemetryCorrelationHttpModule" />
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" preCondition="integratedMode,managedHandler" />
      <!-- ApplicationInsightsWebTracking was available upon new build -->
      <remove name="ApplicationInsightsWebTracking" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" preCondition="managedHandler" />
    </modules>
    <validation validateIntegratedModeConfiguration="false" />
  </system.webServer>
  
  
  <system.diagnostics>
    <trace autoflush="true" indentsize="0">
      <listeners>
        <!--
        TODO: Removed me
        <add name="myAppInsightsListener" type="Microsoft.ApplicationInsights.TraceListener.ApplicationInsightsTraceListener, Microsoft.ApplicationInsights.TraceListener" />
        -->
      </listeners>
    </trace>
  </system.diagnostics>


</configuration>